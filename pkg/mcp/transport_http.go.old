package mcp

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/ebarron/ONTAP-MCP/pkg/ontap"
	"github.com/ebarron/ONTAP-MCP/pkg/util"
	"github.com/google/uuid"
)

// Session represents an MCP session with lifecycle tracking
type Session struct {
	ID             string
	CreatedAt      time.Time
	LastActivityAt time.Time
	ActivityCount  int
	ClusterManager *ontap.ClusterManager // Per-session cluster isolation
	mu             sync.RWMutex
	responseWriter http.ResponseWriter    // For SSE streaming
	flusher        http.Flusher          // For flushing SSE data
}

// SessionManager manages MCP sessions for HTTP transport with automatic cleanup
type SessionManager struct {
	sessions          map[string]*Session
	mu                sync.RWMutex
	logger            *util.Logger
	inactivityTimeout time.Duration
	maxLifetime       time.Duration
	cleanupTicker     *time.Ticker
	cleanupStopChan   chan struct{}
}

// NewSessionManager creates a new session manager with automatic cleanup
func NewSessionManager(logger *util.Logger) *SessionManager {
	sm := &SessionManager{
		sessions:          make(map[string]*Session),
		logger:            logger,
		inactivityTimeout: 20 * time.Minute,
		maxLifetime:       24 * time.Hour,
		cleanupStopChan:   make(chan struct{}),
	}
	
	// Start automatic cleanup
	sm.startCleanup()
	
	logger.Info().
		Dur("inactivity_timeout", sm.inactivityTimeout).
		Dur("max_lifetime", sm.maxLifetime).
		Msg("Session manager initialized with automatic cleanup")
	
	return sm
}

// CreateSession creates a new session with isolated cluster manager
func (sm *SessionManager) CreateSession(logger *util.Logger) *Session {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	now := time.Now()
	session := &Session{
		ID:             uuid.New().String(),
		CreatedAt:      now,
		LastActivityAt: now,
		ActivityCount:  0,
		ClusterManager: ontap.NewClusterManager(logger), // Per-session isolation
		clients:        make(map[chan []byte]bool),
	}

	sm.sessions[session.ID] = session
	
	sm.logger.Info().
		Str("session_id", session.ID).
		Int("active_sessions", len(sm.sessions)).
		Msg("Session created")
	
	return session
}

// UpdateActivity updates session activity timestamp
func (sm *SessionManager) UpdateActivity(sessionID string) {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	if session, exists := sm.sessions[sessionID]; exists {
		session.LastActivityAt = time.Now()
		session.ActivityCount++
	}
}

// GetSession retrieves a session by ID
func (sm *SessionManager) GetSession(id string) (*Session, bool) {
	sm.mu.RLock()
	defer sm.mu.RUnlock()

	session, ok := sm.sessions[id]
	return session, ok
}

// AddClient adds an SSE client to a session
func (s *Session) AddClient(ch chan []byte) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.clients[ch] = true
}

// RemoveClient removes an SSE client from a session
func (s *Session) RemoveClient(ch chan []byte) {
	s.mu.Lock()
	defer s.mu.Unlock()
	delete(s.clients, ch)
	close(ch)
}

// Broadcast sends a message to all SSE clients in a session
func (s *Session) Broadcast(data []byte) {
	s.mu.RLock()
	defer s.mu.RUnlock()

	for ch := range s.clients {
		select {
		case ch <- data:
		default:
			// Client is slow or disconnected, skip
		}
	}
}

// ServeHTTP runs the MCP server in HTTP/SSE mode (for browser integration)
func (s *Server) ServeHTTP(ctx context.Context, port int) error {
	sessionMgr := NewSessionManager(s.logger)

	mux := http.NewServeMux()

	// SSE endpoint - establishes connection and sends session ID
	mux.HandleFunc("/mcp", func(w http.ResponseWriter, r *http.Request) {
		s.handleSSE(w, r, sessionMgr)
	})

	// Message endpoint - receives JSON-RPC requests
	mux.HandleFunc("/messages", func(w http.ResponseWriter, r *http.Request) {
		s.handleMessages(ctx, w, r, sessionMgr)
	})

	// Health check endpoint
	mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]string{"status": "ok"})
	})

	// CORS middleware
	handler := corsMiddleware(mux)

	addr := fmt.Sprintf(":%d", port)
	server := &http.Server{
		Addr:    addr,
		Handler: handler,
	}

	// Graceful shutdown
	go func() {
		<-ctx.Done()
		s.logger.Info().Msg("Shutting down HTTP server...")
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		server.Shutdown(shutdownCtx)
	}()

	s.logger.Info().
		Int("port", port).
		Msg("HTTP server listening")

	if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		return fmt.Errorf("HTTP server error: %w", err)
	}

	return nil
}

// handleSSE handles SSE connections
func (s *Server) handleSSE(w http.ResponseWriter, r *http.Request, sessionMgr *SessionManager) {
	// Set SSE headers
	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")
	w.Header().Set("Access-Control-Allow-Origin", "*")

	// Create session with per-session cluster manager
	session := sessionMgr.CreateSession(s.logger)

	s.logger.Info().
		Str("session_id", session.ID).
		Msg("New SSE connection established")

	// Send endpoint event with session ID
	fmt.Fprintf(w, "event: endpoint\n")
	fmt.Fprintf(w, "data: %s\n\n", session.ID)
	w.(http.Flusher).Flush()

	// Create client channel
	clientChan := make(chan []byte, 10)
	session.AddClient(clientChan)
	defer session.RemoveClient(clientChan)

	// Keep connection alive and send messages
	for {
		select {
		case <-r.Context().Done():
			s.logger.Debug().
				Str("session_id", session.ID).
				Msg("SSE client disconnected")
			return
		case data := <-clientChan:
			fmt.Fprintf(w, "event: message\n")
			fmt.Fprintf(w, "data: %s\n\n", data)
			w.(http.Flusher).Flush()
		}
	}
}

// handleMessages handles JSON-RPC requests
func (s *Server) handleMessages(ctx context.Context, w http.ResponseWriter, r *http.Request, sessionMgr *SessionManager) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Get session ID from query parameter or header
	sessionID := r.URL.Query().Get("sessionId")
	if sessionID == "" {
		sessionID = r.Header.Get("Mcp-Session-Id")
	}

	if sessionID == "" {
		http.Error(w, "Missing session ID", http.StatusBadRequest)
		return
	}

	session, ok := sessionMgr.GetSession(sessionID)
	if !ok {
		http.Error(w, "Invalid session ID", http.StatusNotFound)
		return
	}

	// Parse JSON-RPC request
	var req JSONRPCRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		s.logger.Error().
			Err(err).
			Msg("Failed to parse JSON-RPC request")

		resp := NewJSONRPCError(nil, ErrCodeParseError, "Parse error", err.Error())
		s.sendResponse(w, session, resp)
		return
	}

	// Handle request
	resp := s.HandleRequest(ctx, &req)

	// Update session activity
	sessionMgr.UpdateActivity(sessionID)

	// Send response
	s.sendResponse(w, session, resp)
}

// sendResponse sends a JSON-RPC response via HTTP and SSE
func (s *Server) sendResponse(w http.ResponseWriter, session *Session, resp *JSONRPCResponse) {
	respBytes, err := json.Marshal(resp)
	if err != nil {
		s.logger.Error().
			Err(err).
			Msg("Failed to marshal response")
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	// Send via HTTP response
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBytes)

	// Also broadcast via SSE
	session.Broadcast(respBytes)
}

// startCleanup starts the automatic session cleanup goroutine
func (sm *SessionManager) startCleanup() {
	sm.cleanupTicker = time.NewTicker(60 * time.Second)

	go func() {
		for {
			select {
			case <-sm.cleanupTicker.C:
				sm.cleanupExpiredSessions()
			case <-sm.cleanupStopChan:
				sm.cleanupTicker.Stop()
				return
			}
		}
	}()
}

// cleanupExpiredSessions removes sessions that have exceeded limits
func (sm *SessionManager) cleanupExpiredSessions() {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	now := time.Now()
	expiredCount := 0

	for sessionID, session := range sm.sessions {
		lifetime := now.Sub(session.CreatedAt)
		inactivity := now.Sub(session.LastActivityAt)

		// Check max lifetime or inactivity timeout
		if lifetime > sm.maxLifetime || inactivity > sm.inactivityTimeout {
			reason := "max_lifetime"
			if inactivity > sm.inactivityTimeout {
				reason = "inactivity_timeout"
			}

			sm.logger.Info().
				Str("session_id", sessionID).
				Str("reason", reason).
				Dur("lifetime", lifetime).
				Dur("inactivity", inactivity).
				Int("activity_count", session.ActivityCount).
				Msg("Session expired")

			delete(sm.sessions, sessionID)
			expiredCount++
		}
	}

	if expiredCount > 0 {
		sm.logger.Debug().
			Int("expired_count", expiredCount).
			Int("remaining_sessions", len(sm.sessions)).
			Msg("Session cleanup completed")
	}
}

// Stop stops the cleanup goroutine
func (sm *SessionManager) Stop() {
	close(sm.cleanupStopChan)
	if sm.cleanupTicker != nil {
		sm.cleanupTicker.Stop()
	}
}

// corsMiddleware adds CORS headers
func corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, Mcp-Session-Id")

		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusOK)
			return
		}

		next.ServeHTTP(w, r)
	})
}
