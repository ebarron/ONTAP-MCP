// Fix-It Modal - Confirmation dialog for executing corrective actions
// Shows action details, resolves parameters, and executes MCP tools

class FixItModal {
    constructor(apiClient, parameterResolver) {
        this.apiClient = apiClient;
        this.parameterResolver = parameterResolver;
        this.currentAction = null;
        this.currentAlert = null;
        this.modalElement = null;
        
        this.createModal();
    }

    createModal() {
        // Create modal HTML structure (NetApp BlueXP style)
        const modalHTML = `
            <div id="fixItModal" class="modal-overlay" style="display: none;">
                <div class="modal-container">
                    <div class="modal-header">
                        <h2 id="fixItModalTitle">Confirm Fix-It Action</h2>
                        <button class="modal-close" onclick="fixItModal.close()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div id="fixItModalDescription" class="modal-description"></div>
                        
                        <div id="fixItModalParams" class="modal-params">
                            <!-- Parameters will be injected here -->
                        </div>
                        
                        <div id="fixItModalWarning" class="modal-warning" style="display: none;">
                            <strong>⚠️ Warning:</strong> <span id="fixItModalWarningText"></span>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="button-secondary" onclick="window.fixItModal.close()">Cancel</button>
                        <button id="fixItModalConfirm" class="button-primary" onclick="window.fixItModal.execute()">
                            Execute Fix-It Action
                        </button>
                    </div>
                    
                    <!-- Progress overlay -->
                    <div id="fixItModalProgress" class="modal-progress" style="display: none;">
                        <div class="spinner"></div>
                        <p id="fixItModalProgressText">Executing action...</p>
                    </div>
                </div>
            </div>
        `;

        // Inject modal into DOM
        document.body.insertAdjacentHTML('beforeend', modalHTML);
        this.modalElement = document.getElementById('fixItModal');
        
        // Add modal styles
        this.injectStyles();
    }

    injectStyles() {
        const styles = `
            <style>
                .modal-overlay {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.5);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
                
                .modal-container {
                    background: white;
                    border-radius: 8px;
                    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
                    max-width: 600px;
                    width: 90%;
                    max-height: 80vh;
                    overflow: auto;
                    position: relative;
                }
                
                .modal-header {
                    padding: 20px 24px;
                    border-bottom: 1px solid #e1e5e9;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }
                
                .modal-header h2 {
                    margin: 0;
                    font-size: 20px;
                    font-weight: 600;
                    color: #333;
                }
                
                .modal-close {
                    background: none;
                    border: none;
                    font-size: 28px;
                    color: #666;
                    cursor: pointer;
                    padding: 0;
                    width: 32px;
                    height: 32px;
                    line-height: 1;
                }
                
                .modal-close:hover {
                    color: #333;
                }
                
                .modal-body {
                    padding: 24px;
                }
                
                .modal-description {
                    font-size: 14px;
                    color: #333;
                    margin-bottom: 20px;
                    line-height: 1.5;
                }
                
                .modal-params {
                    background: #f8f9fa;
                    border: 1px solid #e1e5e9;
                    border-radius: 4px;
                    padding: 16px;
                    margin-bottom: 20px;
                }
                
                .modal-params h4 {
                    margin: 0 0 12px 0;
                    font-size: 14px;
                    font-weight: 600;
                    color: #333;
                }
                
                .param-item {
                    margin-bottom: 12px;
                }
                
                .param-item:last-child {
                    margin-bottom: 0;
                }
                
                .param-label {
                    font-size: 12px;
                    font-weight: 600;
                    color: #666;
                    margin-bottom: 4px;
                    display: block;
                }
                
                .param-value {
                    font-size: 14px;
                    color: #333;
                    font-family: 'Monaco', 'Courier New', monospace;
                    background: white;
                    padding: 8px;
                    border-radius: 3px;
                    border: 1px solid #d1d5d9;
                }
                
                .modal-warning {
                    background: #fff3cd;
                    border: 1px solid #ffc107;
                    border-radius: 4px;
                    padding: 12px;
                    font-size: 13px;
                    color: #856404;
                }
                
                .modal-footer {
                    padding: 16px 24px;
                    border-top: 1px solid #e1e5e9;
                    display: flex;
                    justify-content: flex-end;
                    gap: 12px;
                }
                
                .button-primary, .button-secondary {
                    padding: 8px 20px;
                    border-radius: 4px;
                    font-size: 14px;
                    font-weight: 600;
                    cursor: pointer;
                    border: none;
                    transition: all 0.2s;
                }
                
                .button-primary {
                    background: #0067C5;
                    color: white;
                }
                
                .button-primary:hover {
                    background: #0056a3;
                }
                
                .button-secondary {
                    background: white;
                    color: #333;
                    border: 1px solid #d1d5d9;
                }
                
                .button-secondary:hover {
                    background: #f8f9fa;
                }
                
                .modal-progress {
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(255, 255, 255, 0.95);
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    border-radius: 8px;
                }
                
                .spinner {
                    width: 40px;
                    height: 40px;
                    border: 4px solid #e1e5e9;
                    border-top-color: #0067C5;
                    border-radius: 50%;
                    animation: spin 1s linear infinite;
                }
                
                @keyframes spin {
                    to { transform: rotate(360deg); }
                }
                
                #fixItModalProgressText {
                    margin-top: 16px;
                    font-size: 14px;
                    color: #666;
                }
            </style>
        `;
        
        document.head.insertAdjacentHTML('beforeend', styles);
    }

    /**
     * Show the Fix-It modal with a specific action
     * @param {object} action - The solution object from parsed corrective actions
     * @param {object} alert - The alert object with labels and context
     */
    async show(action, alert) {
        this.currentAction = action;
        this.currentAlert = alert;

        // Build modal title with cluster and volume context
        let title = action.solution_title;
        const clusterName = alert.labels?.cluster;
        
        // Determine source type and name from labels (mirrors AlertsView.renderAlertRow logic)
        let sourceType = '-';
        let sourceName = '-';
        
        if (alert.labels.volume) {
            sourceType = 'Volume';
            sourceName = alert.labels.volume;
        }

        if (clusterName) {
            title += ` (${clusterName}`;
            if (sourceType === 'Volume' && sourceName !== '-') {
                title += ` / ${sourceName}`;
            }
            title += ')';
        }    /**
     * Resolve parameters for the action using ParameterResolver
     */
    async resolveParameters(action, alert) {
        const params = {};
        
        // Extract context from alert
        const clusterName = alert.labels?.cluster;
        const volumeName = alert.labels?.volume;
        const svmName = alert.labels?.svm;
        
        console.log('🔍 Resolving parameters for alert:', {
            cluster: clusterName,
            svm: svmName,
            volume: volumeName,
            allLabels: alert.labels
        });
        
        // Always need cluster and volume UUID
        params.cluster_name = clusterName;
        
        // Resolve volume UUID
        if (volumeName && svmName) {
            params.volume_uuid = await this.parameterResolver.resolveVolumeUUID(clusterName, svmName, volumeName);
            params.volume_name = volumeName;
        }
        
        // Tool-specific parameter resolution
        switch (action.mcp_tool) {
            case 'cluster_enable_volume_autosize':
                params.mode = 'grow';
                
                // Get current volume size and calculate maximum
                const currentSize = await this.parameterResolver.getCurrentVolumeSize(clusterName, volumeName);
                const suggestedMax = this.parameterResolver.suggestAutosizeMaximum(currentSize, 'double');
                params.maximum_size = this.parameterResolver.formatSize(suggestedMax);
                params.grow_threshold_percent = 85;
                break;
                
            case 'cluster_update_volume':
                // Determine if this is "set new size" or "add to size"
                const currentVolumeSize = await this.parameterResolver.getCurrentVolumeSize(clusterName, volumeName);
                const currentUsedPercent = await this.parameterResolver.getCurrentVolumeUsedPercent(clusterName, volumeName);
                
                if (action.solution_title.includes('Set New')) {
                    // Calculate size to bring to ~80% utilization
                    const newSize = this.parameterResolver.suggestNewSize(currentVolumeSize, currentUsedPercent, 'reduce_to_80');
                    params.size = this.parameterResolver.formatSize(newSize);
                } else {
                    // Add 20% to current size
                    const newSize = this.parameterResolver.suggestNewSize(currentVolumeSize, currentUsedPercent, 'add_20_percent');
                    params.size = this.parameterResolver.formatSize(newSize);
                }
                break;
                
            case 'cluster_delete_volume_snapshot':
                // Find oldest snapshot
                const snapshots = await this.parameterResolver.suggestSnapshotsToDelete(
                    clusterName, 
                    params.volume_uuid, 
                    1
                );
                
                if (snapshots && snapshots.length > 0) {
                    params.snapshot_uuid = snapshots[0].uuid;
                    params.snapshot_name = snapshots[0].name;
                } else {
                    throw new Error('No snapshots found to delete');
                }
                break;
        }
        
        return params;
    }

    /**
     * Render resolved parameters in the modal
     */
    renderParameters(params) {
        const paramsContainer = document.getElementById('fixItModalParams');
        
        let html = '<h4>Action Parameters:</h4>';
        
        for (const [key, value] of Object.entries(params)) {
            // Skip internal params
            if (key.endsWith('_name')) continue;
            
            // Format parameter name
            const label = key.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
            
            html += `
                <div class="param-item">
                    <span class="param-label">${label}:</span>
                    <div class="param-value">${value}</div>
                </div>
            `;
        }
        
        paramsContainer.innerHTML = html;
    }

    /**
     * Execute the Fix-It action
     */
    async execute() {
        // Show progress overlay
        document.getElementById('fixItModalProgress').style.display = 'flex';
        document.getElementById('fixItModalProgressText').textContent = 'Executing action...';
        
        try {
            // Call MCP tool
            const result = await this.apiClient.callMcp(
                this.currentAction.mcp_tool,
                this.resolvedParams
            );
            
            console.log('✅ Fix-It action executed successfully:', result);
            
            // Show success message
            this.showSuccess(result);
            
        } catch (error) {
            console.error('❌ Fix-It action failed:', error);
            this.showError(error.message || 'Action failed');
        }
    }

    /**
     * Show success message and close modal
     */
    showSuccess(result) {
        // Update progress text
        document.getElementById('fixItModalProgressText').innerHTML = 
            '✅ Action completed successfully!<br><br>Refreshing alert data...';
        
        // Store undo information for reversible actions
        this.storeUndoInfo();
        
        // Close modal after 2 seconds and refresh alerts
        setTimeout(() => {
            this.close();
            
            // Refresh alerts view if available (alertsView is a global variable)
            if (typeof alertsView !== 'undefined' && alertsView.loadAlerts) {
                alertsView.loadAlerts();
            }
            
            // Show toast notification with undo option
            this.showSuccessWithUndo();
        }, 2000);
    }
    
    /**
     * Store undo information in sessionStorage for reversible actions
     */
    storeUndoInfo() {
        const action = this.currentAction;
        const alert = this.currentAlert;
        
        // Only store undo for reversible actions
        const reversibleActions = {
            'cluster_enable_volume_autosize': {
                undoTool: 'cluster_enable_volume_autosize',
                undoParams: (params) => ({
                    cluster_name: params.cluster_name,
                    volume_uuid: params.volume_uuid,
                    mode: 'off'
                }),
                undoLabel: 'Disable Autosize'
            }
            // Add more reversible actions here in the future
        };
        
        if (reversibleActions[action.mcp_tool]) {
            const reversibleAction = reversibleActions[action.mcp_tool];
            const undoInfo = {
                timestamp: Date.now(),
                alertFingerprint: alert.fingerprint,
                actionTitle: action.solution_title,
                originalTool: action.mcp_tool,
                originalParams: this.resolvedParams,
                undoTool: reversibleAction.undoTool,
                undoParams: reversibleAction.undoParams(this.resolvedParams),
                undoLabel: reversibleAction.undoLabel,
                clusterName: alert.labels?.cluster,
                volumeName: alert.labels?.volume
            };
            
            sessionStorage.setItem('lastFixItAction', JSON.stringify(undoInfo));
            console.log('💾 Stored undo info:', undoInfo);
        }
    }
    
    /**
     * Show success toast with undo option
     */
    showSuccessWithUndo() {
        const undoInfo = sessionStorage.getItem('lastFixItAction');
        
        if (undoInfo) {
            const info = JSON.parse(undoInfo);
            const message = `Fix-It action completed successfully`;
            
            // Show toast with undo button
            this.showToast(message, 'success', {
                undoLabel: info.undoLabel,
                onUndo: () => this.executeUndo(info)
            });
        } else {
            this.showToast('Fix-It action completed successfully', 'success');
        }
    }
    
    /**
     * Execute undo action
     */
    async executeUndo(undoInfo) {
        try {
            console.log('⏪ Executing undo:', undoInfo);
            
            // Show progress
            this.showToast('Undoing action...', 'info');
            
            // Execute undo via MCP
            const result = await this.apiClient.callMcp(undoInfo.undoTool, undoInfo.undoParams);
            
            // Clear undo info
            sessionStorage.removeItem('lastFixItAction');
            
            // Show success
            this.showToast('Action undone successfully', 'success');
            
            // Refresh alerts
            if (typeof alertsView !== 'undefined' && alertsView.loadAlerts) {
                alertsView.loadAlerts();
            }
        } catch (error) {
            console.error('Failed to undo action:', error);
            this.showToast(`Failed to undo: ${error.message}`, 'error');
        }
    }

    /**
     * Show error message
     */
    showError(message) {
        document.getElementById('fixItModalProgress').style.display = 'none';
        
        alert('Error: ' + message);
    }

    /**
     * Show toast notification
     */
    showToast(message, type = 'info') {
        // Reuse existing toast system if available
        if (window.toastNotifications) {
            window.toastNotifications.show(message, type);
        } else {
            console.log(`[Toast] ${type}: ${message}`);
        }
    }

    /**
     * Close the modal
     */
    close() {
        this.modalElement.style.display = 'none';
        this.currentAction = null;
        this.currentAlert = null;
        this.resolvedParams = null;
        
        // Reset progress overlay
        document.getElementById('fixItModalProgress').style.display = 'none';
    }
}
